grammar org.rra.adaptationModel.AdaptationModelDSL with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "platform:/resource/org.rra.cdmModel.model/models/cdmModel.ecore" as cdmModel
import "http://www.rra.org/cdmmodel" as cdmModel
import "http://www.rra.org/datatypesmodel" as dtModel
import "http://www.hyperflex.org/featuremodels" as featureModel
//import "platform:/resource/org.hyperflex.featuremodels.model/models/featureModel.ecore" as featuremModel
import "http://www.rra.org/runtimeFeatureModel" as rtFeatureModel

generate adaptationModelDSL "http://www.rra.org/adaptationModel/AdaptationModelDSL"

AdaptationModel:
	(imports+=Import*)
	'name' name=QualifiedName ';' 
	'frequency' frequency=INT ';' 
	(adaptationRules+=AdaptationRule*)
// 	(rules+=Rule*)
// 	(ruleSets+=RuleSet*);
;

//terminal NUMBER returns ecore::EBigDecimal:
//    (('0'..'9')+ ('.' ('0'..'9')*)? | '.' ('0'..'9')+)
//    (('e' | 'E') ('+' | '-')? ('0'..'9')+)?
//;
 	


//terminal VALUE returns ecore::EString: '"' ('0'..'9' | 'a'..'z' | '0'..'9' '.' '0'..'9')+'"';

//terminal AND             returns ecore::EString: 'AND';
//terminal OR              returns ecore::EString:  'OR' ;
//terminal IF              returns ecore::EString: 'if';
//terminal ELSE            returns ecore::EString: 'else';
//terminal THEN            returns ecore::EString: 'then';
//terminal RULE_TERMINAL   returns ecore::EString: 'rule';
//terminal SELECT          returns ecore::EString: 'select feature';
//terminal DESELECT        returns ecore::EString: 'deselect feature';
//terminal CHANGE          returns ecore::EString: 'change feature attribute';
//terminal WITH            returns ecore::EString: 'with';
//terminal IMPORT_TERMINAL returns ecore::EString: 'import';
//terminal AS              returns ecore::EString: 'as';
//terminal SMALLER		 returns ecore::EString: '<';
//terminal BIGGER			 returns ecore::EString: '>';
//terminal EQUAL		     returns ecore::EString: '==';
//terminal NOT_EQUAL		returns ecore::EString: '<>'
//terminal SELECT_WHERE    returns ecore::EString: 'select feature * where';
//terminal FROM 		   returns ecore::EString: 'from';

Import:
	'import' importURI=STRING ';' //AS name=ID
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

QualifiedName:
	ID ('.' ID)*
;	

AdaptationRule:
 	AtomicRule | RuleSet
;
	
// It's necessary that condition and action are part of the same element
	
//AtomicRule:
//	'rule' name=ID ':' 
//	('if' '(' condition+=Condition+ ')')? (atomicAction+=AtomicAction+) 
//	('else' ('if' '(' condition+=Condition ')' )* atomicAction+=AtomicAction+)* ';'
//;

AtomicRule:
	'rule' name=ID ':' 
	conditionAction+=ConditionAction ';'
//	('else' conditionAction+=ConditionAction)* ';'
;

RuleSet:
	
	'rule_set' name=ID ':'
	('if' '(' condition+=Condition+ ')')? '{'  actions+=AtomicActionWithPriority+ '}'
	('else' ('if' '(' condition+=Condition ')' )* '{'  actions+=AtomicActionWithPriority+ '}' )*  ';'
;

AtomicAction:
	(SelectAction | DeselectAction | ModifyAttribute | QueryAction) 'AND'?
;

//ConditionAction :
//	('if('condition+=Condition+ ')')? '{' atomicActions+=AtomicAction+ '}'
//;

// If is optional. Be sure that it is not possible to write something like
// - action else condition action
// - if condition action else action else action
ConditionAction:
	('if' '(' condition+=Condition+ ')')? atomicActions+=AtomicAction+
	('else' (else=ConditionAction) ?)?
;

AtomicActionWithPriority:
	'priority' priorityValue=INT '{' atomicAction+=AtomicAction* '}'
;

//Condition:
//		measurementComparison+=MeasurementComparison 
//;
Condition:
		measurementComparison=MeasurementComparison 
;

// Find a better name for secondTerm
// Find a way of using parenthesis for priority between operators
// Replace the content of Condition with the content of this term.
MeasurementComparison:
	measurement=[ cdmModel::ContextDependentMeasurement|QualifiedName ] 
	operator=OPERATOR value=STRING 
	( logicalOp=LOGICAL_OPERATOR secondTerm=MeasurementComparison )?
;

//Condition:
//	measurement=[ cdmModel::ContextDependentMeasurement|QualifiedName ] OPERATOR STRING 
//	(LOGICAL_OPERATOR meas+=[Import] OPERATOR STRING)*  
//;


OPERATOR:
	'<' | '>' | '==' | '<>'	
;

LOGICAL_OPERATOR:
	'AND' | 'OR' 
;

//MATH_OPERATOR:
//	MAX | MIN | AVG 
//;
//
//AVG:
//	'AVG (' (measurement+=[ cdmModel::ContextDependentMeasurement|QualifiedName ] ',')+ ')' 
//;
//
//MIN:
//	'MIN (' (measurement+=[ cdmModel::ContextDependentMeasurement|QualifiedName ] ',')+ ')'
//;
//
//MAX:
//	'MAX (' (measurement+=[ cdmModel::ContextDependentMeasurement|QualifiedName ] ',')+ ')'
//;



QueryAction:
	'select_feature_*' 
	'from_variants_of_feature' '(' feature=[ featureModel::Feature|QualifiedName ] ')'
	'where_attribue' QueryOperator '(' value=STRING ')'  
;

QueryOperator:
	'max' | 'min'
;

//QueryAction:
	//SELECT_WHERE MATH_OPERATOR  
	//FROM feature+=[Import] 
	//(LOGICAL_OPERATOR SELECT WHERE mathOp+=MATH_OPERATOR FROM feature+=[Import])*
//;

SelectAction:
	'activate_feature' '(' feature=[featureModel::Feature|QualifiedName ] ')'	
;

DeselectAction:
	'deactivate_feature' '(' feature=[featureModel::Feature|QualifiedName ] ')'
;

ModifyAttribute:
	'set_attribute' '(' featureAttribute=[rtFeatureModel::CVAttribute|QualifiedName ] ')' 
	'with_value' '(' attributeValue+=AttributeValue ')' 
;

AttributeValue:
	
	StringAttributeValue | NFRAttributeValue
;

StringAttributeValue:
	value=STRING	
;

NFRAttributeValue:
	 value=[ rtFeatureModel::NFRAttribute|QualifiedName ]
;
